#!/usr/bin/env python3
import argparse
import re
from pathlib import Path

import wasmtime


def load_wasm(wasm_path: Path):
    engine = wasmtime.Engine()
    module = wasmtime.Module.from_file(engine, str(wasm_path))

    # wasm 只需要 env.abort(i32,i32,i32,i32)
    def abort(a, b, c, d):
        return None

    store = wasmtime.Store(engine)
    linker = wasmtime.Linker(engine)
    abort_type = wasmtime.FuncType([wasmtime.ValType.i32(), wasmtime.ValType.i32(), wasmtime.ValType.i32(), wasmtime.ValType.i32()], [])
    linker.define(store, "env", "abort", wasmtime.Func(store, abort_type, abort))

    instance = linker.instantiate(store, module)
    exports = instance.exports(store)
    return store, exports


def write_string(store, exports, s: str) -> int:
    mem = exports["memory"]
    new = exports["__new"]
    data = s.encode("utf-16le")
    ptr = new(store, len(data), 1)
    mem.write(store, data, ptr)
    return ptr


def read_string(store, exports, ptr: int) -> str:
    mem = exports["memory"]
    # size stored at ptr-4 (AssemblyScript string header)
    size_bytes = mem.read(store, ptr - 4, ptr)
    size = int.from_bytes(size_bytes, "little")
    data = mem.read(store, ptr, ptr + size)
    return data.decode("utf-16le")


def decode_image_url(store, exports, encoded: str, debug: bool = False) -> str:
    if not encoded:
        return ""
    if re.search(r"\.jpg|\.png|\.webp", encoded, re.I):
        return encoded
    decode_from_string = exports["decodeFromString"]
    in_ptr = write_string(store, exports, encoded)
    if debug:
        print(f"in_ptr={in_ptr}")
        try:
            in_round = read_string(store, exports, in_ptr)
            print(f"in_roundtrip={in_round[:60]}")
        except Exception as e:
            print(f"in_roundtrip_error={e}")
    out_ptr = decode_from_string(store, in_ptr)
    if debug:
        print(f"out_ptr={out_ptr}")
    if debug and out_ptr == 0:
        print("out_ptr=0 (decode failed)")
    result = read_string(store, exports, out_ptr)
    if debug:
        try:
            mem = exports["memory"]
            size = int.from_bytes(mem.read(store, out_ptr - 4, out_ptr), "little")
            print(f"out_size_bytes={size}")
        except Exception as e:
            print(f"read_size_error={e}")
    return result


def to_992(url: str) -> str:
    if not url:
        return ""
    if "imageMogr2/thumbnail/" in url:
        return re.sub(r"imageMogr2/thumbnail/\d+x\d+!", "imageMogr2/thumbnail/992x992!", url)
    if "-cos" in url:
        return url + "?imageMogr2/thumbnail/992x992!"
    return url


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("encoded", help="encoded imageUrl string")
    parser.add_argument(
        "--wasm-file",
        default="/Users/hummingbird/Develop/anjuke-demo/scripts/optimized.wasm",
        help="path to optimized.wasm",
    )
    parser.add_argument("--raw", action="store_true", help="do not force 992x992")
    parser.add_argument("--debug", action="store_true", help="print debug info")
    args = parser.parse_args()

    wasm_path = Path(args.wasm_file)
    if not wasm_path.exists():
        raise FileNotFoundError(f"optimized.wasm not found: {wasm_path}")

    store, exports = load_wasm(wasm_path)
    decoded = decode_image_url(store, exports, args.encoded, debug=args.debug)
    if args.debug:
        print(f"decoded_raw={decoded}")
    if not args.raw:
        decoded = to_992(decoded)
    if args.debug:
        print(f"decoded_final={decoded}")
    print(decoded)


if __name__ == "__main__":
    main()
